\chapter{Parser}
\todo[inline]{Dibs Aaron}

\section{Changes to the grammar}

In order to successfully implement an $LL$ parser, we first needed to eleminate left-recursive elements from the original SPL grammar.
The elements in question were located in the \textsf{FArgs}, \textsf{Field}, and \textsf{Exp} rules.

For a complete overview of the implemented grammar, please see Appendix \ref{ch:grammar}.
This section will detail the the changes made to the original grammar.

\subsection{Removing left recursion}

The first two rules, \textsf{FArgs} and \textsf{Field}, were trivial to change.
Hence, the transformed rules read as follows:

\begin{framed}
	\begin{grammar}
	<FArgs> ::= <id> [ `,' <FArgs> ]

	<Field> ::= [ `.' (`hd' | `tl' | `fst' | `snd') <Field> ]
	\end{grammar}
\end{framed}

However, the \textsf{Exp} field required more work to transform its binary operations.

\subsection{Transforming binary operations}

The original grammar defined binary operations within the \textsf{Exp} rule as a combination of two expressions and an operator: \textsf{Exp} \textsf{Op2} \textsf{Exp}.
We dealt with the left recursion here by unrolling the binary expressions, taking their operator precedence into account:

\begin{framed}
	\begin{grammar}
		<Exp> ::= <Exp2> `:' <Exp> | <Exp2>

		<Exp2> ::= <Exp3> `\textbar\textbar' <Exp2> | <Exp3>

		<Exp3> ::= <Exp4> `\&\&' <Exp3> | <Exp4>

		<Exp4> ::= <Exp5> (`==' | `\textless' | `\textgreater' | `\textless=' | `\textgreater=' | `!=') <Exp4> | <Exp5>

		<Exp5> ::= <Exp6> (`+' | `-') <Exp5> | <Exp6>

		<Exp6> ::= <ExpW> (`*' | `/' | `\%') <Exp6> | <ExpW>

		<ExpW> ::= <id> <Field>
			\alt <Op1> <Exp>
			\alt <int>
			\alt <char>
			\alt `False' | `True'
			\alt `(' <Exp> `)'
			\alt <FunCall>
			\alt `[]'
			\alt `(' <Exp> `,' <Exp> `)'
	\end{grammar}
\end{framed}

The \textsf{Exp} rule now starts with an attempt to read a cons operation.
If this fails, we fall through to the logical or operation, et cetera, until we ultimately reach what we call `weak' expressions, \textsf{ExpW}.

Clearly, these new rules have removed left recursion, while retaining expressiveness of expressions.
As an added bonus, the order of operations is now more clearly defined.

\subsection{Additional changes}

The \textsf{FunType} rule was modified to make its arrow optional for functions without any arguments:

\begin{framed}
	\begin{grammar}
	<FunType> ::= [ <FTypes> `\textrightarrow' ] <RetType>
	\end{grammar}
\end{framed}

\section{Parser Combinators}

One of our main reasons for choosing Haskell was the prospect of being able to work with parser combinators.
Combined with Haskell's powerful type system, these combinators make processing a source file into an abstract syntax tree (AST) particularly easy.

Rather than implementing combinators ourselves, we opted to use the popular MegaParsec library.
This is a fork of the popular, but no longer maintained, Parsec library.
Added features include full Unicode support, as well as better testing equipment for use with HSpec.

In the rest of this section, we will explain the workings of these combinators by example.

Consider the data structure in listing \ref{lst:splfield_ast}, defining the \textsf{Field} component of our grammar:

\begin{listing}
\begin{framed}
\begin{minted}{haskell}
data SplField = SplFieldHd  SplField
              | SplFieldTl  SplField
              | SplFieldFst SplField
              | SplFieldSnd SplField
              | SplFieldNone
\end{minted}
\end{framed}
\caption{Definition of SplField in SplAST.hs.}
\label{lst:splfield_ast}
\end{listing}

To parse such a field, the \spl{field} function is invoked after reading an identifier.
Listing \ref{lst:splfield_parser} shows the code for this function:

\begin{listing}
\begin{framed}
\begin{minted}{haskell}
field :: Parser SplField
field = char '.' *> (
            readKw "hd"  *> (SplFieldHd  <$> field)
        <|> readKw "tl"  *> (SplFieldTl  <$> field)
        <|> readKw "fst" *> (SplFieldFst <$> field)
        <|> readKw "snd" *> (SplFieldSnd <$> field)
    ) <* sc
    <|> return SplFieldNone
    where
        readKw :: String -> Parser ()
        readKw w = string w *> notFollowedBy alphaNumChar
\end{minted}
\end{framed}
\caption{Definition of the \texttt{field} parser in \texttt{SplParser.hs}.}
\label{lst:splfield_parser}
\end{listing}

From quickly reading the funtion, it becomes apparent that it covers all five possible fields: head, tail, first, and second.
Three helper functions are used:
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\item \texttt{char}, which tries to read one Unicode character.
	\item \texttt{sc}, which greedily reads and discards white\textbf{s}paces and \textbf{c}omments.
	\item \texttt{readKw}, which reads a particular \textbf{k}ey\textbf{w}ord.
\end{itemize}

The \spl{field} function has two main branches.
At the start, we try to read a `.' to indicate a field.
If no period can be read, the \spl{SplFieldNone} token is yielded.

Otherwise, we enter a branch with the \texttt{*>} combinator.
In the branch, we try to read either of four keywords, followed by another word using the \texttt{<\$>} binding operator.
Note that the \texttt{<|>} combinator facilitates in branching.

Because we used the \texttt{*>} combinator, the result of the branch is yieled as the result of the outer block. If no result is obtained, a parse error is generated.

Finally, we consume any remaining whitespace or comments using the aforementioned \spl{sc} helper function.

Note that, at this stage, we do not verify whether \spl{hd} or \spl{tl} is applied to a list, nor whether \spl{fst} or \spl{snd} is applied to a tuple.
This is left for the type inferencer, which the next chapter will cover.

\section{Testing}

\todo[inline]{Testing, how does it work?}

\section{Pretty Printing}
\todo[inline]{printer combinators}

\section{Reflection}
\todo[inline]{combinators are awesome. AST not fancy enough: records for extensibility, include locations for error messages}
