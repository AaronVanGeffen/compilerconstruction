\chapter{AArch64}

AArch64 is the 64-bit instruction set supported by ARMv8 ARM CPUs.
In this section we will describe the architecture and how we tried to implement code generation.

\todo[inline]{Dibs Thom}

\section{Architecture Outline}

Our development platform is the ODROID-C2.
It is a Cortex-A53-based Android development board, but it can also run Linux.
It provides a quadcore CPU running at 1536 MHz and 2 gigabytes of RAM\@.

AArch64 provides 31 general-purpose registers $r0, \ldots, r30$.
This is excluding the stack pointer or the program counter.
Return addresses aren't put on the stack but done through the special \emph{link register} (r30).
This register can also be used as a callee-saved register where the value is written to memory.

In general, instructions on ARM have got distinct inputs and an output.
They take their inputs as registers and write their output to a register.
In AArch64 there are no special restrictions on the registers with regards to operations, i.e.\ each register can be used for every operation.
This allows for fewer restrictions in register allocation.

Registers can be addressed in 32-bit and 64-bit modes.
When accessed in a 32-bit fashion, the registers are written as $w0, \ldots, w30$.
When accessed in a 64-bit fashion, the registers are written as $x0, \ldots, x30$.
We will use the 64-bit registers in all generated code.

\section{Calling Convention}

We follow the C calling convention as defined in~\cite{callingconvention}.
This allows easier linking into \texttt{libc} methods.
We use these for printing numbers and variables.

The calling convention can be briefly summarised as follows.
The arguments to a function are passed via registers $r0, \ldots, r7$.
If there are more than seven arguments, the rest of the arguments are put on the stack.
The registers $r0, \ldots, r18$ are temporary or caller-saved registers.
A subroutine is free to clobber those registers.
If a calling function wishes to preserve their values, it needs to persist them to the stack.
The registers $r19, \ldots, r30$ are callee-saved.
This means that if a subroutine wishes to use them, it needs to save them to the stack.

\section{Register Allocation}

Register allocation is typically done by first transforming the IR of your program into a form that is known as \emph{Single Static Assignment}.
In this format, every variable is only assigned into once.
It is also vital to divide your program in \emph{Basic Blocks} with only one entry point and exit, so the allocation algorithm doesn't need to account for control flow such as jumps.
This information allows to generate better dependency graphs which then helps when applying the actual register allocation.
The register allocation is typically done via some graph colouring algorithm.
If there exists a $K$-colouring of the graph where $K$ is the number of available registers, it is possible to assign registers.
If this isn't possible, some values need to be \emph{spilled} to the stack and the algorithm is restarted.

Because transforming our IR to an SSA form did not appear to be trivial, we opted to ignore it and develop our own register allocation algorithm first.
This is a more quick-and-dirty version that would also simply not be able to handle too many registers.
Our algorithm can be briefly described as follows: first divide the program into basic blocks.
Then we determine what registers are in use for every line of IR\@.
This information is then used to assign registers.

We determine the lifecycle of variables in bottom-up fashion.
For each block, we start at the bottom with an empty list of live registers.
After all, at the end a function will have returned its result.
Then, for each line, we collect the inputs and the output pseudo-registers.
We remove the output from the live registers, and add the inputs to the live registers.
After all, before this line the output value apparently did not make sense, since it needed to be redefined.
Meanwhile the inputs must have existed before this line, otherwise they could not have been inputs.
We then annotate each line with the registers that are live at that point.


\section{Remaining Work}

\section{Reflection}

