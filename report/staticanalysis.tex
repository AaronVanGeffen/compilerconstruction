\chapter{Static Analysis}

In this chapter we will discuss how we approached the static analysis in our compiler.
We started out doing Type Checking, but later implemented the more advanced Type Inference.
We will then show the inference rules and reflect on our implementation.

\todo[inline]{Dibs Thom}
\todo[inline]{ergens scoping}

\section{Type Checking}

Type checking is a fairly simple analysis of a program.
By restricting the analysis to only verifying each specified type matches with what is expected, it is usually possible to treat each line by itself.
This does require a programmer to specify the types for each function or variable.
For some specific constructions, such as the empty list expression (\spl{[]}), this does require some special care: the type of the empty list is not as exactly defined as other constructions.

We implemented type checking by folding a function over the parsed syntax tree.
We track the state in a monad.
The functions recursively handle the nested segments of the declarations, functions, expressions and statements.
They either fail or return the result of the derivation of that segment.
Definitions of functions or variables are kept track of in the state with their derived type.
Encountered identifiers are looked up.

The data structures we used can be found in Listing~\ref{lst:typecheckdatastructures}.
We used several simple utility functions like \haskellinline{disallowVoid} to restrict the results of recursive \haskellinline{typeCheck} calls.
Listing~\ref{lst:typecheckunaryoperations} shows how this is applied for unary operations.

\begin{listing}[hbtp]
    \centering
    \inputhaskell{examples/typecheck_datastructures.hs}
    \caption{Data structures for type checking}\label{lst:typecheckdatastructures}
\end{listing}

\begin{listing}[hbtp]
    \centering
    \inputhaskell{examples/typecheck_unaryops.hs}
    \caption{Type checking unary operations}\label{lst:typecheckunaryoperations}
\end{listing}

We almost fully implemented type checking.
Because we moved on to do type inference, most of this code did not end up in the final compiler.

\section{Type Inference}

While type analysis is easy, it requires the programmer to specify many things in great detail while she is writing a program.
This results in lot of code that should be completely obvious.
It is not necessary to specify in \spl{Int bla = 3;} that \spl{bla} is of type \spl{Int}: this can be easily inferred from the literal \spl{3}.
Requiring to strictly specify types also may lead to having to write several copies of functions.
When writing a function like \spl/id (a) { return a; }/ it would be convenient to have it work for all types, but in languages that only do type checking it is usually not possible to write such a function down.

The general approach of type inference is to instead of deciding at every point if something is decidable, to generate constraints that the operations and functions should meet.
These constraints can thus be more general than concrete types.
By using information found in later sections of the program, these constraints can then be refined.

We implemented Hindley-Milner type inference following the approach laid out in~\cite{writeyouahaskelltypeinf}.
He implements type inference for an untyped lambda calculus, a language that is quite a lot simpler than SPL\@.
But as he writes what he is doing fairly clearly and chooses his data structures well, we were able to extend this to SPL quite easily.

Hindley-Milner type inference works by applying a set of type rules to the lines of code.
When something isn't completely known, this is resolved by inserting a \emph{type variable}.
These variables will then later be \emph{unified} with (concrete) type information to get \emph{substitutions} that can be mapped over the environment again.
By doing this, we apply the knowledge we gain in later bits of code to essentially check the previous bits of code, as substitutions only exist if two types are unifiable.
We will discuss the type rules for SPL in Section~\ref{sec:typerules}.

\section{Type Rules}\label{sec:typerules}

First we need to show how to derive types from the literal type annotations.
We are going to need these for a lot of things, like declarations and function definitions.
\[
\infer{\Gamma \vdash a : \sigma}{(a, \sigma) \in \{(\mbox{`Bool'}, Bool), (\mbox{`Int'}, Int), (\mbox{`Char'}, Char)\} }
\]
We also need a version for lists and tuples.
These can also be used for their expressions.
\[
\infer{\Gamma \vdash [a] : [\sigma]}{\Gamma \vdash a : \sigma}\qquad
\infer{\Gamma \vdash (a, b) : (\sigma, \tau)}{\Gamma \vdash a : \sigma & \Gamma \vdash b : \tau}
\]

Next, we are going to derive expressions:
\begin{align*}
    \infer{\Gamma \vdash i : Int}{i \in \mathbb{Z}} &\qquad \mbox{Integer literals} \\
    \infer{\Gamma \vdash c : Char}{c \in \mathsf{Unicode}} &\qquad \mbox{Character literals} \\
    \infer{\Gamma \vdash b : Bool}{b \in \{\mbox{`True', `False'}\}} &\qquad \mbox{Boolean literals} \\
    \infer{\Gamma \vdash ~b : Bool}{\Gamma \vdash b : Bool} &\qquad \mbox{Unary inversion}\\
    \infer{\Gamma \vdash -i : Int}{\Gamma \vdash i : Int} &\qquad \mbox{Unary negation}\\
    \infer{\Gamma \vdash a\; o\; b : \sigma}{\Gamma \vdash a : \sigma & \Gamma \vdash b : \sigma & \sigma \in \{Char, Int\} & o \in \{+, -\}} &\qquad \mbox{Operations on Ints and Chars}\\
    \infer{\Gamma \vdash a\; o\; b : Int}{\Gamma \vdash a : Int & \Gamma \vdash b : Int & o \in \{*, /, \% \}} &\qquad \mbox{Operations on Ints}\\
\end{align*}
\begin{align*}
    \infer{\Gamma \vdash a\; o\; b : Bool}{\Gamma \vdash a : \sigma & \Gamma \vdash b : \sigma & o \in \{==, !=, <, <=, >=, >\}} &\qquad \mbox{Comparison operations}\\
    \infer{\Gamma \vdash a\mathsf{.hd} : \sigma}{\Gamma \vdash a : [\sigma]} &\qquad \mbox{List head}\\
    \infer{\Gamma \vdash a\mathsf{.tl} : [\sigma]}{\Gamma \vdash a : [\sigma]} &\qquad \mbox{List tail}\\
    \infer{\Gamma \vdash a\mathsf{.fst} : \sigma}{\Gamma \vdash a : (\sigma, \tau)} &\qquad \mbox{Tuple first}\\
    \infer{\Gamma \vdash a\mathsf{.snd} : \tau}{\Gamma \vdash a : (\sigma, \tau)} &\qquad \mbox{Tuple second} \\
    \infer{\Gamma \vdash [] : [\sigma]}{} &\qquad \mbox{Empty List expression}
\end{align*}

Declarations are important as they allow to put new things into the state.
We need to consider following statements and declarations to propagate this definition.
Here we also see that an ordering of types arises: more general types can be substituted for more concrete types.
\[
    \infer{\Gamma \vdash a \; identifier = expr;next}{
        \Gamma \vdash type : \sigma &
        \Gamma \vdash expr : \tau &
        \sigma \sqsubseteq \tau &
        \Gamma,\; identifier : \sigma \vdash next
    }
\]

We need a separate version for declarations with $\mathsf{var}$ as they follow the expression's type instead of the specified type.
\[
    \infer{\Gamma \vdash \mathsf{var} \; identifier = expr;next : \tau}{
        \Gamma \vdash expr : \sigma &
        \Gamma,\; identifier : \sigma \vdash next
    }
\]

Function declarations follow this scheme. For convenience we will consider underspecified functions as functions that have been specified with type variables instead. We will also only consider one argument, but this rule can be extended to no or multiple arguments without loss of generality. We insert the resultant type of this function in the environment when checking the body, to allow asserting return statements.
We also see the first appearance of the $\forall$ quantifier.
Using it allows for multiple uses of variable typed functions.
\[
    \infer{\Gamma \vdash identifier(arg)\; ::\; argtype\; \to\; rettype\; \{\; body\; \}\; next : \phi}{
        \begin{array}{r}
        \Gamma \vdash arg : \sigma \\
        \Gamma \vdash argtype : \tau\\
        \sigma \sqsubseteq \tau \\
        \Gamma \vdash rettype : \rho \\
        \Gamma, \mathsf{returntype} : \rho \vdash body : \alpha \\
        \Gamma, identifier :\forall \tau,\;\rho. \tau \to \rho \vdash next : \phi
        \end{array}
    }
\]
\todo[author=Thom]{Is this correct? I wonder if $\forall \tau, \rho$ works as it should.}

Statements are the remaining meat of the schemes that SPL requires.


\section{Reflection}
\todo[inline]{Haskell is great. No error when specified type is more general than expression, time wasted on checking, poor error messages}


% vim: set ts=4 sw=4 tw=0 et wrap :
