\chapter{Static Analysis}

In this chapter we will discuss how we approached the static analysis in our compiler.
We started out doing Type Checking, but later implemented the more advanced Type Inference.
We will then show the inference rules and reflect on our implementation.

\todo[inline]{Dibs Thom}
\todo[inline]{ergens scoping}

\section{Type Checking}

Type checking is a fairly simple analysis of a program.
By restricting the analysis to only verifying each specified type matches with what is expected, it is usually possible to treat each line by itself.
This does require a programmer to specify the types for each function or variable.
For some specific constructions, such as the empty list expression (\spl{[]}), this does require some special care: the type of the empty list is not as exactly defined as other constructions.

We implemented type checking by folding a function over the parsed syntax tree.
We track the state in a monad.
The functions recursively handle the nested segments of the declarations, functions, expressions and statements.
They either fail or return the result of the derivation of that segment.
Definitions of functions or variables are kept track of in the state with their derived type.
Encountered identifiers are looked up.

The data structures we used can be found in Listing~\ref{lst:typecheckdatastructures}.
We used several simple utility functions like \haskellinline{disallowVoid} to restrict the results of recursive \haskellinline{typeCheck} calls.
Listing~\ref{lst:typecheckunaryoperations} shows how this is applied for unary operations.

\begin{listing}[hbtp]
    \centering
    \inputhaskell{examples/typecheck_datastructures.hs}
    \caption{Data structures for type checking}\label{lst:typecheckdatastructures}
\end{listing}

\begin{listing}[hbtp]
    \centering
    \inputhaskell{examples/typecheck_unaryops.hs}
    \caption{Type checking unary operations}\label{lst:typecheckunaryoperations}
\end{listing}

We almost fully implemented type checking.
Because we moved on to do type inference, most of this code did not end up in the final compiler.

\section{Type Inference}

While type analysis is easy, it requires the programmer to specify many things in great detail while she is writing a program.
This results in lot of code that should be completely obvious.
It is not necessary to specify in \spl{Int bla = 3;} that \spl{bla} is of type \spl{Int}: this can be easily inferred from the literal \spl{3}.
Requiring to strictly specify types also may lead to having to write several copies of functions.
When writing a function like \spl/id (a) { return a; }/ it would be convenient to have it work for all types, but in languages that only do type checking it is usually not possible to write such a function down.

The general approach of type inference is to instead of deciding at every point if something is decidable, to generate constraints that the operations and functions should meet.
These constraints can thus be more general than concrete types.
By using information found in later sections of the program, these constraints can then be refined.

We implemented Hindley-Milner type inference following the approach laid out in~\cite{writeyouahaskelltypeinf}.
He implements type inference for an untyped lambda calculus, a language that is quite a lot simpler than SPL\@.
But as he writes what he is doing fairly clearly and chooses his data structures well, we were able to extend this to SPL quite easily.

Hindley-Milner type inference works by applying a set of type rules to the lines of code.
When something isn't completely known, this is resolved by inserting a \emph{type variable}.
These variables will then later be \emph{unified} with (concrete) type information to get \emph{substitutions} that can be mapped over the environment again.
By doing this, we apply the knowledge we gain in later bits of code to essentially check the previous bits of code, as substitutions only exist if two types are unifiable.
We will discuss the type rules for SPL in Section~\ref{sec:typerules}.

\section{Type Rules}\label{sec:typerules}

\section{Reflection}
\todo[inline]{Haskell is great. No error when specified type is more general than expression, time wasted on checking, poor error messages}


% vim: set ts=4 sw=4 tw=0 et wrap :
